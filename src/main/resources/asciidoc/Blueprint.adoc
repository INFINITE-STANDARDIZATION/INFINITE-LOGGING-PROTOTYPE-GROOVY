= Infinite Logging âˆž BlackBox
Anton Pryamostanov <https://github.com/apryamostanov[@apryamostanov]>
:description: This Blueprint defines the solution to automatically generate Groovy semantic-level logging code and inject it into User code during the compilation resulting in a possibility to produce and review exhaustive application runtime data in a form of XML files with XSD based on simplified Groovy AST class model - by the means of implementing and using a Groovy Annotation.
:keywords: Groovy, AST, annotation, transformation, logging, code injection, semantic logging
:page-description: {description}
:page-keywords: {keywords}
:page-layout: docs
ifndef::env-site[]
:toc: left
:icons: font
:idprefix:
:idseparator: -
:sectanchors:
:source-highlighter: highlightjs
endif::[]
:experimental:
:mdash: &#8212;
:language: asciidoc
:source-language: {language}
:table-caption!:
:example-caption!:
:figure-caption!:
:imagesdir: ../images
:includedir: _includes
:toc: left
:source-highlighter: Coderay coderay
// Refs
:blackbox-blueprint: https://github.com/INFINITE-TECHNOLOGY/BLACKBOX/wiki/Blueprint
:blackbox-code: https://github.com/INFINITE-TECHNOLOGY/BLACKBOX

////
TODO:

////

== Purpose
{description}

== Introduction
Logging is one of the most important parts of modern applications. +
Its significance only increases in case of:

* Financial environments (consider PCI-DSS and sensitive data logging)
* Cloud environments (consider logging to Logstash)
* GDPR

While at a level of Logging engines (Log4J, JUL, Logback -> SLF4J) things are good, there is a theoretical gap in terms of approach and best practices for logging implementation as well as its automation. +
In short there is *no set of rules* helping programmers to understand:

* *What* to log
* *When* to log
* *Where* to place logging code in the application
* *How* log can be used on Test and Production environments
* *Why* spend time writing logging code

When it comes to automation of logging in Java and Groovy, the things are getting really bad:

* Groovy provides annotations (@Slf4j, etc) to inject log variable declaration and initialization

That saves just a couple of lines of code. +
But there is *no real way to inject the actual logging code into the application*. +
Programmers have to manually place lines with logging leading to *unwanted results*:

* Cluttering the real code base with logging code
* Unstructured and cluttered log output
* Chances of misplacing the logging code and missing important output
* Increase of development time and costs

As an Open Source community we are taking an initiative to come up with a new Logging solution addressing these limitations and supporting many additional features. +
The *solution helps* to address the below key scenarios:

* *What* to log:
** 4 levels of logging:
*** Method exceptions (with arguments causing exception)
*** Method execution (with method arguments, result and exceptions)
*** Statements execution within the method (all Groovy statements are supported)
*** Expression execution and evaluation (all Groovy expressions are supported) - with the resulting object value and class
** Compile-time metadata:
*** Line numbers
*** Code snippets
* *When* to log
** 2 operational modes are supported:
*** *Sequential* real-time - *an alternative to using Debugger*.
There are many situations when it is easier to run a program - and then to read the hierarchical execution output like in above example to identify bugs or understand why specific branch of AST has been run. With the Debugger it will take a lot of time by manually putting Breakpoints and Watches.
*** *Emergency* - suitable for using on *Production* - when Unhandled exception happens - the whole AST route with all runtime data (method Arguments, method results, expression values and associated meta data (line numbers, etc)) - is printed up to the place where exception has been encountered. This acts an alternative to Memory dump, with a difference that such trace has retrospective data (not only that last memory snapshot).
* *Where* to place logging code in the application
** Simply add @BlackBox annotation to the method - and the job is done. No need to clutter the actual code with logging lines.
* *How* log can be used on Test and Production environments
** Issue investigation & debugging
** Performance profiling and optimization
** Statistics
** Analytics
** Monitoring
** Telemetry
** Uploading to Logstash
** Applying XSLT to XML
* *Why* spend time writing logging code
** No more time needs to be wasted e.g. on:

====
Finding which specific "return" statement returned by placing logging or using debugger.
====

=== Key Features
==== Code writing stage
===== @BlackBox Annotation
@BlackBox annotation is applicable to:

<1> Methods
<2> Constructors

[source,groovy]
----
@BlackBox
String foo() {
    return "bar"
}
----
To start using BlackBox, add the @BlackBox annotation as shown above. It is as simple as that!

====== 4+1 BlackBox levels
Specify explicitly the needed level of logging code injection granularity by providing "blackBoxLevel" parameter to @BlackBox annotation:

[source,groovy]
----
@BlackBox(blackBoxLevel = BlackBoxLevel.EXPRESSION)
String foo() {
    return "bar"
}
----
There are 5 possible values for the "blackBoxLevel" annotation parameter:

<0> BlackBoxLevel.NONE
<1> BlackBoxLevel.METHOD_ERROR
<2> BlackBoxLevel.METHOD
<3> BlackBoxLevel.STATEMENT
<4> BlackBoxLevel.EXPRESSION

==== Compilation stage
During the compilation phase BlackBox performs transformation of methods and constructors having the @BlackBox annotation.
As the result Method/Constructor code is modified having the additional logging added, while the method signatures and the actual functionality of the method are preserved.

===== Method transformation and Log code injection levels
====== Method Error
*Before:*
[source,groovy]
----
@BlackBox(blackBoxLevel = BlackBoxLevel.METHOD_ERROR)
String foo(String bar) {
    return bar
}
----

*After:*
[source,groovy,linenums]
----
String foo(String bar) {
    try {
        return bar
    } catch (java.lang.Throwable automaticThrowable) {
        io.infinite.blackbox.BlackBoxEngine automaticBlackBox = io.infinite.blackbox.BlackBoxEngine.getInstance()
        automaticBlackBox.methodExecutionOpen('SandBox', 'io.infinite.blackbox', 'foo', 5, 6, 29, 32, ['bar': bar])
        automaticBlackBox.exception(automaticThrowable)
        automaticBlackBox.executionClose()
        throw automaticThrowable
    }
}
----

Method code is enclosed into Try/Catch statement and in case exception happens during execution of method code - it is logged *along with the method parameters which caused the exception.* +

IMPORTANT: *This is one of the key functionalities of BlackBox* - in this scenario there is practically no performance impact on normal application execution - however if unhandled exception occurs - *we are now automatically aware of the Method Arguments which caused the exception.*

====== Method
*Before:*
[source,groovy]
----
@BlackBox(blackBoxLevel = BlackBoxLevel.METHOD)
String foo(String bar) {
    return bar
}
----

*After:*
[source,groovy,linenums]
----
String foo(String bar) {
    io.infinite.blackbox.BlackBoxEngine automaticBlackBox = io.infinite.blackbox.BlackBoxEngine.getInstance()
    automaticBlackBox.methodExecutionOpen('SandBox', 'io.infinite.blackbox', 'foo', 5, 6, 29, 32, ['bar': bar ])
    try {
        automaticBlackBox.executeMethod({
            return bar
        })
    }
    catch (java.lang.Throwable automaticThrowable) {
        automaticBlackBox.exception(automaticThrowable)
        throw automaticThrowable
    }
    finally {
        automaticBlackBox.executionClose()
    }
}
----

<1> Method code is *enclosed with Closure* and Try/Catch statement.
<2> Method code execution is preceeded with *logging of method arguments*.
<3> Method code closure is passed to "executeMethod" which *logs method result*.
<3> Any exception are logged
<4> Finally method execution completion is logged (regardless of whether it is due to unhandled exception or Return statement).

NOTE: Method arguments, result and exceptions are logged. Method code is not modified.

====== Statement
*Before:*
[source,groovy]
----
@BlackBox(blackBoxLevel = BlackBoxLevel.STATEMENT)
String foo(String bar) {
    return bar
}
----

*After:*
[source,groovy,linenums]
----
String foo(String bar) {
    io.infinite.blackbox.BlackBoxTransformation - io.infinite.blackbox.BlackBoxEngine automaticBlackBox = io.infinite.blackbox.BlackBoxEngine.getInstance()
    automaticBlackBox.methodExecutionOpen('SandBox', 'io.infinite.blackbox', 'foo', 5, 6, 29, 32, ['bar': bar ])
    try {
        automaticBlackBox.executeMethod({
            automaticBlackBox.preprocessControlStatement('ReturnStatement', '\nreturn bar \n', 9, 19, 31, 31, 'BlockStatement:statements')
            return bar
        })
    }
    catch (java.lang.Throwable automaticThrowable) {
        automaticBlackBox.exception(automaticThrowable)
        throw automaticThrowable
    }
    finally {
        automaticBlackBox.executionClose()
    }
}
----

* BlackBox level "STATEMENT" performs same steps as "METHOD", however *it also transforms the method code.* +
* The *statements* within the method are transformed according to BlackBox transformation rules, adding logging to method execution while preserving the original functional flow of the method code. +
* For example in the above method the BlackBox transformation encloses "Return" statement into a closure, which is executed with logging of the line numbers and other meta data of "Return" statement during runtime.

====== Expression
*Before:*
[source,groovy]
----
@BlackBox(blackBoxLevel = BlackBoxLevel.EXPRESSION)
String foo(String bar) {
    return bar
}
----

*After:*
[source,groovy,linenums]
----
String foo(String bar) {
    io.infinite.blackbox.BlackBoxEngine automaticBlackBox = io.infinite.blackbox.BlackBoxEngine.getInstance()
    automaticBlackBox.methodExecutionOpen('SandBox', 'io.infinite.blackbox', 'foo', 5, 6, 29, 32, ['bar': bar ])
    try {
        automaticBlackBox.executeMethod({
            automaticBlackBox.preprocessControlStatement('ReturnStatement', '\nreturn bar \n', 9, 19, 31, 31, 'BlockStatement:statements')
            return automaticBlackBox.expressionEvaluation('VariableExpression', 'bar ', 16, 19, 31, 31, {
                return bar
            }, 'ReturnStatement:expression')
        })
    }
    catch (java.lang.Throwable automaticThrowable) {
        automaticBlackBox.exception(automaticThrowable)
        throw automaticThrowable
    }
    finally {
        automaticBlackBox.executionClose()
    }
}
----

* BlackBox level "EXPRESSION" performs same steps as "STATEMENT", however *it also transforms the expressions.* +
* The *expressions* within the method are transformed according to BlackBox transformation rules, adding logging to method execution while preserving the original functional flow of the method code. +
* This helps to log the expression evaluation results and have an exhaustive runtime data for methods having BlackBox annotation.
* For example in the above method the BlackBox transformation encloses "Return" statement *expression* into a closure, which is executed with logging of the line numbers and other meta data of expression during runtime - *as well as expression evaluation result*.

==== Runtime
The injected/transformed code is taking it's effect during runtime (execution) of user program. +
The runtime behavior can be controlled by 2 factors:

* BlackBox System Property "blackbox.mode" which can accept the values from *BlackBoxMode* enumeration and define the Operation Mode (see below section):
** BlackBoxMode.SEQUENTIAL - corresponds to Real-time sequential Operation mode of BlackBox
** BlackBoxMode.EMERGENCY - corresponds to Emergency Operation mode of BlackBox

Sample code snippet to set the property programmatically:
----
System.setProperty("blackbox.mode", BlackBoxMode.SEQUENTIAL.value())
----

* Slf4j->Logback configuration - BlackBox currently uses only Logback via Slf4j as logging engine. Therefore normal Logback configuration methodology will affect the logs produced by BlackBox.

BlackBox currently uses Logback *debug* level for its output. +
There are 2 classes producing the debug output:

* io.infinite.blackbox.BlackBoxEngineSequential
* io.infinite.blackbox.BlackBoxEngineEmergency
For example to enable BlackBox output in Spring Boot *application.properties* define parameters:
----
logging.level.io.infinite.blackbox.BlackBoxEngineSequential=debug
logging.level.io.infinite.blackbox.BlackBoxEngineEmergency=debug
----

===== Operating modes
BlackBox provides 2 operating modes for different usage scenarios.

====== Real-time sequential
This mode is useful for *development/debugging* acting as a supplement/alternative approach to using a Debugger. +
In this mode the logging code injected during compilation phase (as per BlackBox level values defined during writing the code) is executed and the results *immediately sent to Logback for printing the logs.* +
For example *execution* of the below code:

[source,groovy]
----
package io.infinite.blackbox

class SandBox implements Runnable {

    @BlackBox(blackBoxLevel = BlackBoxLevel.EXPRESSION)
    String foo(String bar) {
        return bar
    }

    @Override
    void run() {
        foo("z")
    }
}
----

Will *output* the following results:
----
15:59:49.150 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential - <rootAstNode startDateTime="2018-10-22T15:59:49.120+04:00" xmlns="https://i-t.io/logging/groovy/2_x_x/Main" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
15:59:49.151 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -     <astNodeList>
15:59:49.182 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -         <astNode xsi:type="MethodNode" methodName="foo" className="io.infinite.blackbox.SandBox" startDateTime="2018-10-22T15:59:49.156+04:00" lineNumber="29" columnNumber="5" lastLineNumber="32" lastColumnNumber="6">
15:59:49.182 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -             <argumentList>
15:59:49.182 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                 <argument argumentClassName="java.lang.String" argumentName="bar">
15:59:49.211 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                     <argumentValue>z</argumentValue>
15:59:49.213 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                 </argument>
15:59:49.213 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -             </argumentList>
15:59:49.213 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -             <astNodeList>
15:59:49.219 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                 <astNode xsi:type="Statement" statementClassName="ReturnStatement" startDateTime="2018-10-22T15:59:49.217+04:00" sourceNodeName="BlockStatement:statements" lineNumber="31" columnNumber="9" lastLineNumber="31" lastColumnNumber="19">
15:59:49.220 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                     <restoredScriptCode>
return bar
</restoredScriptCode>
15:59:49.220 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                     <astNodeList>
15:59:49.224 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                     </astNodeList>
15:59:49.224 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                 </astNode>
15:59:49.227 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                 <astNode xsi:type="Expression" expressionClassName="VariableExpression" startDateTime="2018-10-22T15:59:49.226+04:00" sourceNodeName="ReturnStatement:expression" lineNumber="31" columnNumber="16" lastLineNumber="31" lastColumnNumber="19">
15:59:49.228 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                     <restoredScriptCode>bar </restoredScriptCode>
15:59:49.228 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                     <astNodeList>
15:59:49.232 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                     </astNodeList>
15:59:49.232 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                     <expressionValue className="java.lang.String">
15:59:49.232 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                         <value>z</value>
15:59:49.232 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                     </expressionValue>
15:59:49.232 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                 </astNode>
15:59:49.233 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -             </astNodeList>
15:59:49.233 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -             <methodResult className="java.lang.String">
15:59:49.233 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                 <value>z</value>
15:59:49.233 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -             </methodResult>
15:59:49.234 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -         </astNode>
z
15:59:49.255 [BlackBoxEngine Shutdown Hook 13] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -     </astNodeList>
15:59:49.256 [BlackBoxEngine Shutdown Hook 13] DEBUG io.infinite.blackbox.BlackBoxEngineSequential - </rootAstNode>

Process finished with exit code 0
----

From the above output we can easily track what methods are being called with which parameters, their execution flow and effects as well as results. +
*We know all what happens in the application up to each and every bit.*

====== Emergency
This mode is useful for *production* usage providing details only in case when unhandled exception occurs. +

IMPORTANT: In this mode BlackBox remains *silent* and does not produce any logging debug output unless exception is encountered. +
Output is printed only in case when exception is encountered. +
Printed output is only relevant to encountered exception. Irrelevant data is not printed.

In this mode the logging code injected during compilation phase (as per BlackBox level values defined during writing the code) is executed and the results are *accumulated in RAM without printing the output*. +
*Successful* completed AST execution results are *discarded* from RAM.
In case when *exception* occurs - those AST execution in RAM that are incomplete (in progress) at the time of exception encouter - are sent to Logback for printing. +
For example *execution* of the below code:

[source,groovy]
----
package io.infinite.blackbox

class SandBox implements Runnable {

    @BlackBox(blackBoxLevel = BlackBoxLevel.EXPRESSION)
    String foo(String bar) {

        return bar
    }

    @Override
    void run() {
        foo("z")
    }
}
----

Will *output* the following results (only after exception occurs):

----
16:17:41.085 [Compilation_SandBox.foo] ERROR io.infinite.blackbox.BlackBoxEngineEmergency - <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<rootAstNode xsi:type="MethodNode" methodName="foo" className="io.infinite.blackbox.SandBox" startDateTime="2018-10-22T16:17:40.843+04:00" lineNumber="29" columnNumber="5" lastLineNumber="35" lastColumnNumber="6" xmlns="https://i-t.io/blackbox/groovy/2_x_x/Main" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <astNodeList/>
    <argumentList>
        <argument argumentClassName="java.lang.String" argumentName="bar">
            <argumentValue>foobar</argumentValue>
        </argument>
    </argumentList>
    <exception exceptionDateTime="2018-10-22T16:17:40.913+04:00">
        <exceptionStackTrace>java.lang.Exception: Bar can not be foobar
	at io.infinite.blackbox.SandBox$_foo_closure1$_closure3.doCall(SandBox.groovy:32)
	at io.infinite.blackbox.SandBox$_foo_closure1$_closure3.doCall(SandBox.groovy)
	at io.infinite.blackbox.BlackBoxEngine.expressionEvaluation(BlackBoxEngine.groovy:70)
	at io.infinite.blackbox.BlackBoxEngine$expressionEvaluation$3.call(Unknown Source)
	at io.infinite.blackbox.SandBox$_foo_closure1.doCall(SandBox.groovy:32)
	at io.infinite.blackbox.SandBox$_foo_closure1.doCall(SandBox.groovy)
	at io.infinite.blackbox.BlackBoxEngine.executeMethod(BlackBoxEngine.groovy:175)
	at io.infinite.blackbox.BlackBoxEngine$executeMethod$1.call(Unknown Source)
	at io.infinite.blackbox.SandBox.foo(SandBox.groovy)
	at io.infinite.blackbox.SandBox.run(SandBox.groovy:40)
</exceptionStackTrace>
    </exception>
</rootAstNode>
----

NOTE: Every exception causes such printing only once and during it's first encouter within the BlackBox annotated methods.

NOTE: Only AST Nodes that are part of exception execution stack are printed. Unneeded successful branches of AST that did not cause this exception are discarded and not stored/printed.

== Principles
This section describes basic principles in the foundation of BlackBox solution. +

=== Thread safety
NOTE: Java execution stack thread affinity is *immutable*. +
This guarantees that even in Application server deployment - *execution started in a specific thread - will always take place and end only and only within the same thread*. +
See also: https://stackoverflow.com/questions/52605879/java-application-servers-execution-stack-thread-affinity +

BlackBox is maintaining the application execution stack in a variable in the instances of BlackBoxEngine class. +
Therefore we need to ensure that each and every thread using BlackBox engine has a designated instance of BlackBoxEngine class. +
This is achieved by having a static ThreadLocal field in BlackBoxEngine and accessing the dedicated-per-thread BlackBoxEngine via *getInstance* method:

----
io.infinite.blackbox.BlackBoxEngine automaticBlackBox = io.infinite.blackbox.BlackBoxEngine.getInstance()
----

NOTE: Above code is provided for information only and it is not required to manually initialize BlackBoxEngine - all the necessary job is done by the injected code automatically.

NOTE: Java application servers interfere with normal java.lang.ThreadLocal class instances. Therefore BlackBox is currently using its own (simplified) implementation of ThreadLocal (which is just a Map<Thread, BlackBoxEngine>).

=== Memory leakage prevention
Runtime data can accumulate indefinitely therefore it is needed to ensure that the portion of Runtime data maintained by BlackBox (in RAM) corresponds only to current active branch of AST execution. +
Completed AST branches are discarded from storage in BlackBoxEngine execution stack.

=== Code equivalency
Since @BlackBox annotation is performing transformation of user code, as a base principle of transformation it needed to ensure that the transformed code is *equivalent* to the initial user code in terms of its actual functionality excluding the additional injected logging code. +
This principle should guarantee that @BlackBox annotation can be safely added to any existing or new Groovy methods and constructors, minimizing risk of regression issues.

=== Transformation rules
BlackBox follows a clearly defined set of code transformation rules. +
Rules of transformation depend on BlackBox level.

==== Method Error transformation
====
[source,groovy]
----
try {
    <original Method Code> # <1>
} catch (java.lang.Throwable automaticThrowable) {
    io.infinite.blackbox.BlackBoxEngine automaticBlackBox = io.infinite.blackbox.BlackBoxEngine.getInstance()
    automaticBlackBox.methodExecutionOpen(<metadata>, <method arguments>) # <2> <3>
    automaticBlackBox.exception(automaticThrowable)
    automaticBlackBox.executionClose()
    throw automaticThrowable
}
----
<1> Unmodified original method code
<2> Meta data includes:
* Method declaring class package name
* Method declaring class simple name
* Method name
* First and last line and column numbers of the method code
<3> Method arguments at their state when exception has been catched
====

NOTE: *visit* method is *NOT* called on method code and the AST traversing/transformation terminates  at this stage.

==== Method transformation
====
[source,groovy]
----
io.infinite.blackbox.BlackBoxEngine automaticBlackBox = io.infinite.blackbox.BlackBoxEngine.getInstance()
automaticBlackBox.methodExecutionOpen(<metadata>, <method arguments>) # <1> <2>
try {
    automaticBlackBox.executeMethod({
        <original method code> # <3>
    })
}
catch (java.lang.Throwable automaticThrowable) {
    automaticBlackBox.exception(automaticThrowable)
    throw automaticThrowable
}
finally {
    automaticBlackBox.executionClose()
}
----
<1> Meta data includes:
* Method declaring class package name
* Method declaring class simple name
* Method name
* First and last line and column numbers of the method code
<2> Method arguments at their state *before* method execution
<3> Unmodified original method code
====

NOTE: *visit* method is *NOT* called on method code and the AST traversing/transformation terminates  at this stage.

==== Statement transformations
Statement transformations happen for BlackBox level "Statement" and above. +
In addition to "Method" transformation, *visit* method is called on method code and all statements are transformed according to the below rules:

*Return, Continue, Break, Throw statements:*

These statements represent a special case as they affect the application execution stack. Each one of them has a different scope of effect, and this scope is resolved at runtime using *preprocessControlStatement* method. +
Therefore such statements have to be logged and transformed using different rules than other statements.

[source,groovy]
----
automaticBlackBox.preprocessControlStatement(<Control statement class name>, <Original Untransformed Control Statement Code String>, <control statement start and end line and column numbers>, <source AST node variable name>)
<original control statement (Return, Continue, Break or Throw)>
----

Example:
[source,groovy]
----
automaticBlackBox.preprocessControlStatement('ThrowStatement', 'throw new java.lang.Exception(\'Bar can not be foobar\')\n', 13, 57, 32, 32, 'BlockStatement:statements')
throw new java.lang.Exception('Bar can not be foobar')
----

*All other statements:*

[source,groovy]
----
automaticBlackBox.statementExecutionOpen(<Statement Class Name>, <Original Untransformed Statement Code String>, <statement start and end line and column numbers>, <source AST node variable name>)
<recursively transformed statement - child statements and expressions (if needed) transformed>
automaticBlackBox.executionClose()
----

Example:
[source,groovy]
----
automaticBlackBox.statementExecutionOpen('IfStatement', 'if ( bar == \'foobar\') {\n    throw new java.lang.Exception(\'Bar can not be foobar\')\n}\n', 9, 10, 31, 33, 'BlockStatement:statements')
if ( bar == 'foobar') {
    automaticBlackBox.preprocessControlStatement('ThrowStatement', 'throw new java.lang.Exception(\'Bar can not be foobar\')\n', 13, 57, 32, 32, 'BlockStatement:statements')
    throw new java.lang.Exception('Bar can not be foobar')
}
automaticBlackBox.executionClose()
----

==== Expression transformations
Expression transformations happen for BlackBox level "Expression". +
Due to current AST limitations (see https://issues.apache.org/jira/browse/GROOVY-8834) and syntax/semantics it is not possible to directly replace each and every expression with a wrapper. +
Therefore the expression transformation follows the rules in the below table:

[cols=",a,a"]
|===
|Condition |Transformation |Comments

|Null expression
|No transformation
|

|EmptyExpression
|No transformation
|

|MapEntryExpression
|No transformation
|Synthetic expression added by Groovy compiler; not possible to be replaced (it evaluates into key value pair)

|ArgumentListExpression
|Synthetic expression added by Groovy compiler; not possible to be replaced (it evaluates into list of objects)
|

|DeclarationExpression
|Transformed into ListOfExpressionsExpression:

* Call to expressionExecutionOpen
* Transformed declaration expression (only right expression transformed as per this table recursively).
* Call to executionClose
|

* Left expression is never transformed (this is *declaration*!)
* Right expression is transformed.
* Usage of ListOfExpressionsExpression is a hack
** it works in similar way to BlockStatement - however such usage was not in the initial design of Groovy AST.

|Null expression
|No transformation

|Null expression
|No transformation

|Null expression
|No transformation

|Null expression
|No transformation

|Null expression
|No transformation

|Null expression
|No transformation

|Null expression
|No transformation

|Null expression
|No transformation

|Null expression
|No transformation

|Null expression
|No transformation

|Null expression
|No transformation
|===

== Solution architecture

=== Groovy class model
==== BlackBox
==== BlackBoxEngine
==== BlackBoxEngineEmergency
==== BlackBoxEngineHierarchical
==== BlackBoxEngineSequential
==== BlackBoxLevel
==== BlackBoxMode
==== BlackBoxTransformation
==== BlackBoxVisitor
==== ThreadLocal
=== Runtime engine API
==== expressionExecutionOpen
==== expressionEvaluation
==== methodExecutionOpen
==== statementExecutionOpen
==== executionClose
==== preprocessControlStatement
==== initRootAstNode
==== executeMethod
==== exception
=== XSD model
==== XSD class model diagram
==== BlackBox
==== ASTNode
==== ASTNodeList
==== MethodNode
==== Expression
==== Statement
==== Argument
==== ArgumentList
==== ASTTrace
==== Object
==== Exception
== Risks
=== Performance
==== ThreadLocal usage
==== Closure usage
=== Security
==== Automatic logging of sensitive data
=== Test coverage and code disruption
== Usage
=== Preparation
==== Checkout
==== Building
=== In the code
==== Import using Gradle
==== Using annotation
=== During the runtime